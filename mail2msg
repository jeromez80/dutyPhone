#!/usr/bin/env python
import smtpd, email, ConfigParser, os, errno, MySQLdb
import asyncore, signal

class CustomSMTPServer(smtpd.SMTPServer):
    
    def process_message(self, peer, mailfrom, rcpttos, data):
        global POLLPATHSMS, POLLPATHWA
        print 'Receiving message from:', peer
        print 'Message addressed from:', mailfrom
        print 'Message addressed to  :', rcpttos
        print 'Message length        :', len(data)
	dmsg = email.message_from_string(data)
	if dmsg.is_multipart():
		for payload in dmsg.get_payload():
		# if payload.is_multipart(): ...
			print 'Handling multipart payload'
			print payload.get_payload()
			dpayload = dmsg.get_payload()
	else:
		print dmsg.get_payload()
		dpayload = dmsg.get_payload()

	dpayload = dpayload.replace('=0D=0A', '\n')
	if POLLPATHSMS != '':
		f=open(u'{0}msgSMTP.txt'.format(POLLPATHSMS), 'w+')
		f.write(dpayload)
		f.close()
	if POLLPATHWA != '':
		f=open(u'{0}msgSMTP.txt'.format(POLLPATHWA), 'w+')
		f.write(dpayload)
		f.close()
        return

def signal_handler(signal, frame):
	global pidfile
	os.unlink(pidfile)
        exit(0)

def pid_exists(pid):
    """Check whether pid exists in the current process table.
    UNIX only.
    """
    if pid < 0:
        return False
    if pid == 0:
        # According to "man 2 kill" PID 0 refers to every process
        # in the process group of the calling process.
        # On certain systems 0 is a valid PID but we have no way
        # to know that in a portable fashion.
        raise ValueError('invalid PID 0')
    try:
        os.kill(pid, 0)
    except OSError as err:
        if err.errno == errno.ESRCH:
            # ESRCH == No such process
            return False
        elif err.errno == errno.EPERM:
            # EPERM clearly means there's a process to deny access to
            return True
        else:
            # According to "man 2 kill" possible error values are
            # (EINVAL, EPERM, ESRCH)
            raise
    else:
	return True

def getListeningPort():
	global DBHOST, DBUSER, DBPASS, DBNAME
	db = MySQLdb.connect(host=DBHOST, user=DBUSER, passwd=DBPASS, db=DBNAME)
	SQLCur = db.cursor()
	SQLCur.execute("SELECT `Config_Value` FROM `ConfigData` WHERE `Config_Key` = 'SMTP_Port';")
	port=SQLCur.fetchone()
	if port:
		return int(port[0])
	else:
		return 25

def getListeningIP():
	global DBHOST, DBUSER, DBPASS, DBNAME
	db = MySQLdb.connect(host=DBHOST, user=DBUSER, passwd=DBPASS, db=DBNAME)
	SQLCur = db.cursor()
	SQLCur.execute("SELECT `Config_Value` FROM `ConfigData` WHERE `Config_Key` = 'SMTP_IP';")
	port=SQLCur.fetchone()
	if port:
		return port[0]
	else:
		return '0.0.0.0'

global POLLPATHWA, POLLPATHSMS
global DBHOST, DBUSER, DBPASS, DBNAME

pid = str(os.getpid())
pidfile = "mail2msg.pid"

if os.path.isfile(pidfile):
    with open(pidfile, 'r') as f:
        curpid=int(f.read().strip())
    if pid_exists(curpid):
        print("%s already exists, exiting" % pidfile)
        exit()
    else:
        print("%s exists, but process is dead. Creating now process file." % pidfile)
file(pidfile, 'w+').write(pid)

signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)

dConfig = ConfigParser.ConfigParser()
dConfig.read("/etc/SmartMessage.conf")
DBHOST = dConfig.get('DB', 'DBHost')
DBUSER = dConfig.get('DB', 'DBUser')
DBPASS = dConfig.get('DB', 'DBPass')
DBNAME = dConfig.get('DB', 'DBName')

LISTENPORT = getListeningPort()
LISTENIP = getListeningIP()

print 'Binding to %s on port %s' % (LISTENIP, LISTENPORT)
server = CustomSMTPServer((LISTENIP, LISTENPORT), None)

asyncore.loop()
